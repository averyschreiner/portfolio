<!DOCTYPE html>
<html lang = "en"
    <head>
        <!--name of tab-->
        <title>Avery's Portfolio</title>

        <!--required for proper behavior on mobile devices-->
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!--bootstrap css-->
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css"
        rel="stylesheet" 
        integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi"
        crossorigin="anonymous">

        <!--our css file-->
        <link rel="stylesheet" type="text/css" href="style.css" />
    </head>
    <body>
        <nav class="navbar sticky-top bg-light">
            <div class="container-fluid">
              <a class="navbar-brand" href="#">Sticky top</a>
            </div>
        </nav>
        <a name="top"></a>

        <!--homepage-->
        <h1>Hello, I am Avery.</h1><br>
        <div class="container text-center">
            <div class="row justify-content-around">
                <div class="col-4">
                    <h2>About Me</h2>
                    <p>
                        Currently, I am  studying Computer Science at Northwest Missouri State University. 
                        This is my third year at Northwest, and I am becoming more and more excited to join the 
                        software/technology industry after graduation. My hometown is Brookfield, Missouri, a small 
                        town in North Central Missouri. In my free time, I often find myself being around my 
                        close friends, playing chess, or going to the gym. 
                    </p>
                </div>
                <div class="col-4">
                    <h2>Contact</h2>
                    <p><a href="mailto:schreineravery@gmail.com" target="_blank" rel="noopener noreferrer">schreineravery@gmail.com</a></p>
                    <p><a href="https://www.linkedin.com/in/avery-schreiner-84978224b/" target="_blank" rel="noopener noreferrer">LinkedIn</a></p>
                    <p>660 - 229 - 1915</p>
                    <!--maybe include a nice picture of self here-->
                </div>
            </div>

            <!--section divider-->
            <br><hr><br>

            <!--minimal spanning tree project-->
            <div class="row justify-content-around">
                <div class="col-4">
                    <h2>Minimal Spanning Tree Project</h2>
                    <br>
                    <!--general project description-->
                    <p>
                        This project dives into two different approaches in finding the minimal spanning tree
                        of tree structures. I implemented both Prim's and Kruskal's alogrithms for finding the
                        minimal spanning tree, and compared how they perfermed over various graph sizes. The graph 
                        library I used for this project was <a href="https://jgrapht.org/" target="_blank"
                         rel="noopener noreferrer">JGraphT</a>.
                    </p>
                    <br>
                    <!--explaining prim's-->
                    <p>
                        In general, Prim's approach is to first pick a node in our graph at random. Once we have an 
                        initial node, we repeatedly pick the lightest edge that connects a node we have visited to 
                        a node we have not, until our number of edges = number of nodes - 1.
                    </p>
                    <br>
                    <!--explaining kruskal's-->
                    <p>
                        Kruskal's algorithm continuously picks the lightest edge, that hasn't already been selected, 
                        that doesn't create a cycle in our minimal spanning tree so far. Again, you repeat this process
                        until our number of edges = number of nodes - 1. 
                    </p>
                    <br>
                    <!--conclusion-->
                    <p>
                        While the different approaches will perform differently depending on how you implement them, 
                        I still think it is interesting to see how they compare as our graph size gets larger. 
                        The sizes (number of edges in the graph) I chose were from the minimum number of edges  
                        (n-1) to the max number of edges a graph can have, in increments of ~500. All of the graphs had
                        100 nodes. The results of the timings can be seen to the right.
                    </p>
                    <br>
                    <!--link-->
                    <p>
                        If you are interested in seeing how I chose to implement this project, feel free to take a look
                        at the <a href="https://github.com/averyschreiner/portfolio/blob/main/MinimalSpanningTrees.java" 
                        target="_blank" rel="noopener noreferrer">souce code</a>.
                    </p>
                </div>
                <div class="col-4">
                    <p>     </p>
                    <br>
                    <p>     </p>
                    <br>
                    <p>     </p>
                    <img src="img/mst_example.png" width="100%">
                    <p>     </p>
                    <br>
                    <p>     </p>
                    <br>
                    <p>     </p>
                    <img src="img/primVsKrusPlot.png" width="100%">
                    <p>
                        (x-axis: number of edges, y-axis: time in nanoseconds)
                    </p>
                </div>
            </div>

            <!--section divider-->
            <br><hr><br>

            <!--max subarray project-->
            <div class="row justify-content-around">
                <div class="col-4">
                    <h2>Max Subarray Project</h2>
                    <br>
                    <p>
                        Like the project above, this project also implements two different approaches, 
                        but in finding the maximum continuous subarray of a given array of integers.  
                    </p>
                    <br>
                    <p>
                        The brute force approach is to try every possible subarray of the array of integers, and 
                        find the one that results in the largest sum. In most cases, there is a better approach 
                        than brute force.
                    </p>
                    <br>
                    <p>
                        Kadane's algorithm is a common solution for finding the maximum continuous subarray. Kadane's 
                        alogorithm runs through the array once, and is always comparing the current running sum to 
                        the best (max) sum so far. 
                    </p>
                    <br>
                    <p>
                        I tested both the brute force method and Kadane's with arrays of size 100 to 1000 in increments  
                        of 100, and plotted the results. As you can see, brute force performs worse and worse as the 
                        array size increases, while Kadane's held up against larger array sizes.
                    </p>
                    <br>
                    <!--link-->
                    <p>
                        If you are interested in seeing how I chose to implement this project, feel free to take a look
                        at the <a href="https://github.com/averyschreiner/portfolio/blob/main/MaxSubArrays.java" 
                        target="_blank" rel="noopener noreferrer">souce code</a>.
                    </p>
                </div>
                <div class="col-4">
                    <p>     </p>
                    <br>
                    <p>     </p>
                    <br>
                    <p>     </p>
                    <br>
                    <p>     </p>
                    <img src="img/msa_example.png" width="100%">
                    <p>     </p>
                    <br>
                    <p>     </p>
                    <br>
                    <p>     </p>
                    <img src="img/bruteVkadane.png" width="100%">
                </div>
            </div>

            <!--section divider-->
            <br><hr><br>

            <!--sudoku project-->
            <h2>Sudoku Solver</h2>
            <br>
            <p>
                The sudoku solver was a project that I found really interesting. Given a semi-empty "sudoku board", 
                this program could figure out the correct solution for the board if a possible solution exists. My approach to this solution was 
                somewhat brute force, and solved it in a recursive fashion. For each empty square (which held a zero), 
                if a number wasn't already in our row, column, or box, we placed that number in the empty square 
                (temporarily), and we made our way to the next empty square and repeated the process until 
                our chosen numbers don't fit into a solvable outcome. Once we realize our number choices from earlier 
                won't result in solving the board, we jump back to the "problem square" to try the next number.
            </p>
            <br>
            <p>
                If you are interested in seeing how I chose to implement this project, feel free to take a look
                at the <a href="https://github.com/averyschreiner/portfolio/blob/main/SudokuBoard.java" 
                target="_blank" rel="noopener noreferrer">souce code</a>.
            </p>
            <br>
            <div class="row justify-content-around">
                <div class="col-4">
                    <img src="img/unsBoard1.png" width="100%">
                    <p>     </p>
                    <br>
                    <p>     </p>
                    <img src="img/unsBoard2.png" width="100%">
                </div>
                <div class="col-4">
                    <img src="img/solvedBoard1.png" width="100%">
                    <p>     </p>
                    <br>
                    <p>     </p>
                    <img src="img/solvedBoard2.png" width="100%">
                </div>
            </div>

            <!--section divider-->
            <br><hr><br>

            <!--sorting times project-->
            <div class="row justify-content-around">
                <div class="col-4">
                    <h2>Timing Sorting Algorithms</h2>
                    <br>
                    <p>
                        In this project, I implemented three different sorting methods to see how they perform against
                        each other as the our list size increases. The methods I wanted to test were Insertion, Selection,
                        and Merge sorts. 
                    </p>
                    <br>
                    <p>
                        If you are interested in seeing how I chose to implement this project, feel free to take a look
                        at the <a href="https://github.com/averyschreiner/portfolio/blob/main/SortingTimes.java" 
                        target="_blank" rel="noopener noreferrer">souce code</a>.
                    </p>
                </div>
                <div class="col-4">
                    <img src="img/SortingAlgorithms.png" width="100%">
                    <p>
                        (x-axis: number of elements, y-axis: time in nanoseconds)
                    </p>
                </div>
            </div>
        </div>

        <!--testing anchor-->
        <a href="#top">Back to top</a>
        <!--bootstrap js-->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js" 
        integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3" 
        crossorigin="anonymous"></script>

    </body>
</html>